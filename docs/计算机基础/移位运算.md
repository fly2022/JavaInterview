在代码中经常使用进行高低位的截取、哈希计算，甚至运用在乘除法运算中。向右移动1位近似表示除以2（如下表所示），十进制的奇数转化为二进制数后，在向右移时，最右边的1将被直接抹去，说明向右移对于奇数并非完全相当于除以2。在左移与右移>两种运算中，符号位均参与移动，除负数往右移动，高位补1之外，其他情况均在空位处补0.

|        正数/负数         | 向左移<<1位  | 向右移>>1位  |
| :----------------------: | :----------: | :----------: |
| 正数（35的补码00100011)  | 01000110=70  | 00010001=17  |
| 负数（-35的补码11011101) | 10111010=-70 | 11101110=-18 |
| 正数（99的补码01100011)  | 11000110=-58 | 00110001=49  |
| 负数（-99的补码10011101) | 00111010=58  | 11001110=-50 |

左移运算由于符号位参与向左移动，在移动后的结果中，最左位可能是1或者0，即正数向左移动的结果可能是正，也可能是负；负数向左移动的结果同样可能是正，也可能是负。

对于三个大于号的>>>无符号向右移动（注意不存在<<<无符号向左移动的运算方式），当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值是1。无符号意即藐视符号位，符号位失去特权，必须像其他平常的数字位一起向右移动，高位直接补0，根本不关心是正数还是负数。

|        正数/负数         | 向右移>>>1位 | 向右移>>>2位 | 向右移>>>3位 |
| :----------------------: | :----------: | :----------: | ------------ |
| 正数（35的补码00100011)  | 00010001=17  |  00001000=8  | 00000100=4   |
| 负数（-35的补码11011101) | 01101110=110 | 00110111=55  | 00011011=27  |

为何负数不断地无符号向右移动的最小值是1呢？在实际编程中，位移运算仅作用于整型（32位）和长整型（64位）数上，假如在整型数上移动的位数是32位，无论是否带符号位以及移动方向，均为本身。因为移动的位数是一个mod 32的结果，即35>>1与35>>33是一样的结果。如果是长整型，mod 64，即35<<1与35<<65的结果是一样的。负数在无符号往右移动63位时，除最右边为1外，左边均为0，达到最小值1，如果>>64，则为其原数值本身。
